<!DOCTYPE html>
<html>
	<head>
		<script src="modfile.js"></script>
		<script src="modplayer.js"></script>
		
		<script type="text/javascript">
			var modPlayer;
			
			var playing = false;
			var bufferOffset = 0; //how far into the buffer we've written
			var sampleRate = 44100;
			var bufferSeconds = 3;
			var bufferInterval = 5;
			var bufferLength = 44100 * 2 * bufferSeconds;
			var modBuffer = new Float32Array(bufferLength); //Float32Array

			/* audiodata.js remnant */
			/*var audioParameters = new AudioParameters(2, sampleRate);     
			var audioSource = new AudioDataMemorySource(audioParameters, modBuffer);
			var audioDestination = new AudioDataDestination();
			audioDestination.writeAsync(audioSource);*/

			//NOTE: Copied from out-of-data Mozilla Wiki example
			//Float32Array.slice no longer exists. Must use Float32Array.subarray
			function AudioDataDestination(sampleRate, readFn) {
				// Initialize the audio output.
				var audio = new Audio();
				audio.mozSetup(2, sampleRate);

				var currentWritePosition = 0;
				var prebufferSize = sampleRate; // buffer 500ms
				var tail = null;

				// The function called with regular interval to populate 
				// the audio output buffer.
				setInterval(function() {
					var written;
					// Check if some data was not written in previous attempts.
					if(tail) {  
						written = audio.mozWriteAudio(tail);
						currentWritePosition += written;
						if (written < tail.length) {
							// Not all the data was written, saving the tail...
							tail = tail.subarray(0, written); //tail = tail.slice(written);
							return; // ... and exit the function.
						}
						tail = null;
					}

					// Check if we need add some data to the audio output.
					var currentPosition = audio.mozCurrentSampleOffset();
					var available = currentPosition + prebufferSize - currentWritePosition;
					if(available > 0) {
						// Request some sound data from the callback function.
						var soundData = new Float32Array(parseFloat(available));
						readFn(soundData);

						// Writing the data.
						written = audio.mozWriteAudio(soundData);
						if(written < soundData.length) {
							// Not all the data was written, saving the tail.
							tail = soundData.subarray(0, written); //tail = soundData.slice(written);
						}
						currentWritePosition += written;
					}
				}, 400);
			}

			// Control and generate the sound.
			var currentSoundSample;
			var sampleRate = 44100;

			function requestSoundData(soundData) {
				if (!playing) { return; }
				var data = modPlayer.getSamples(bufferLength);
				for (var i=0, size=soundData.length; i<size; i++) {
					soundData[i] = data[i];
				}
				currentSoundSample += data.length;
			}

			var audioDestination = new AudioDataDestination(sampleRate, requestSoundData);


			function play() {
				currentSoundSample = 0;
				playing = true;
			}

			function stop() {
				playing = false;
			}

			/* load from harddrive using HTML5 File API */
			function loadLocal(file) {
				var reader = new FileReader();
				/* ugly-ass closure nonsense */
				reader.onload = (function(theFile) {
					return function(e) {
						/* actually load mod once we're passed the file data */
						theFile = e.target.result; /* get the data string out of the blob object */
						var modFile = new ModFile(theFile);
						modPlayer = new ModPlayer(modFile, 44100);
						play();
						document.getElementById('status').innerText = '';
					};
				})(file);

				reader.readAsBinaryString(file);
				document.getElementById('status').innerText = '';
			}

			function loadRemote(path) {
				var fetch = new XMLHttpRequest();
				fetch.open('GET', path);
				fetch.overrideMimeType("text/plain; charset=x-user-defined");
				fetch.onreadystatechange = function() {
					if(this.readyState == 4 && this.status == 200) {
						/* munge response into a binary string */
						var t = this.responseText || "" ;
						var ff = [];
						var mx = t.length;
						var scc= String.fromCharCode;
						for (var z = 0; z < mx; z++) {
							ff[z] = scc(t.charCodeAt(z) & 255);
						}
						var binString = ff.join("");
						
						var modFile = new ModFile(binString);
						modPlayer = new ModPlayer(modFile, 44100);
						play();
						document.getElementById('status').innerText = '';
					}
				}
				document.getElementById('status').innerText = 'loading...';
				fetch.send();
			}
		</script>
	</head>
	<body>
		<h1>JSModPlayer</h1>
		<h2>the imaginatively named Javascript .mod player by Gasman</h2>
		<ul>
			<li><a href="javascript:loadRemote('mods/ambpower.mod')">Ambient Power (Vogue / Triton)</a></li>
			<li><a href="javascript:loadRemote('mods/dope.mod')">Dope / Onward Ride (Jugi / Complex)</a></li>
			<li><a href="javascript:loadRemote('mods/frust.mod')">Mental Frustration (Nugget / Rebels)</a></li>
			<li><a href="javascript:loadRemote('mods/mindkick.mod')">Mindkick (Mindfuck / Mentasm)</a></li>
			<li><a href="javascript:loadRemote('mods/sundance.mod')">Sundance (Purple Motion / Future Crew)</a></li>
			<li><a href="javascript:loadRemote('mods/ode_to_protracker.mod')">Ode to Protracker (Asle / Sylvain Chipaux)</a></li>
			<li>From harddrive: <input type="file" id="input" multiple="true" onchange="loadLocal(this.files[0])"></li>
		</ul>
		<!-- <button onclick="stop()">stop</button> --><p>(refresh the page to stop audio - no proper playback controls yet...)</p>
		<div id="status"></div>
		<p>This is a work in progress - not all effects are implemented yet. Sound output is done with Ben Firshman's <a href="http://github.com/bfirsh/dynamicaudio.js">dynamicaudio.js</a> (using Firefox's audio data API, falling back on Flash if not available).</p>
		<p><a href="http://github.com/gasman/jsmodplayer">source code, on Github</a></p>
		<p><a href="http://twitter.com/westdotcodottt">@westdotcodottt</a> - <a href="http://matt.west.co.tt/">matt.west.co.tt</a> - <a href="mailto:gasman@raww.org">gasman@raww.org</a> - 22 May 2010</p>
	</body>
</html>
